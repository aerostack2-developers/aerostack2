#!/bin/python3

import os
import argparse
import subprocess

SHELL = 'zsh' if os.getenv('ZSH_VERSION') != "" else 'bash'
print(SHELL)
TERM_EXTENSION = f'.{SHELL}'

AS2_WS_PATH = os.getenv('AEROSTACK2_WORKSPACE')
AS2_STACK_PATH = os.getenv('AEROSTACK2_STACK')
AS2_ROS1_WS_PATH = f'{AS2_STACK_PATH}/ros1_stack/ros1_packages/'
AS2_ROS1_BRIDGE_PATH = f'{AS2_STACK_PATH}/ros1_stack/ros1_bridge/'
COLCON_COMMAND = f'colcon build --symlink-install --cmake-args -DCMAKE_BUILD_TYPE=Release'


IS_ROS1_WS = os.path.exists(AS2_ROS1_WS_PATH+"/src")

def send_shell_command(command):
    print(f'SHELL : {SHELL} Executing: {command}')
    if SHELL == 'bash':
        cmd = f"/bin/bash -c \'{command}\'"
    elif SHELL == 'zsh':
        cmd = f"/usr/bin/zsh -c \'{command}\'"
    else:
        print("Shell not supported")
        exit(1)

    # cmd = f"/bin/bash c \'{command}\'"

    process = subprocess.run(cmd, shell=True)


def compile_ros2_ws():
    print("Building Aerostack2 ROS2 PACKAGES")

    send_shell_command(
        f'source {AS2_WS_PATH}/install/setup{TERM_EXTENSION}; source /opt/ros/foxy/setup{TERM_EXTENSION} && cd {AS2_WS_PATH} && {COLCON_COMMAND}')
    # send_shell_command(f'cd {AS2_WS_PATH} && colcon build --symlink-install')


def compile_ros1_ws():
    compile_ros1_bridge()
    if IS_ROS1_WS:
        print("Building Aerostack2 ROS1 PACKAGES")
        # TODO: dinamically choose ros1 distro
        send_shell_command(
            f'source /opt/ros/noetic/setup{TERM_EXTENSION}; cd {AS2_ROS1_WS_PATH} && catkin_make')
    else:
        print('No Aerostack2 ROS1 WS found')


def compile_ros1_bridge():
    if (os.path.exists(AS2_ROS1_BRIDGE_PATH)):
        print("Building ROS1 TO ROS2 BRIDGE")
        send_shell_command(f'source /opt/ros/noetic/setup{TERM_EXTENSION};  \
                        source {AS2_WS_PATH}/install/setup{TERM_EXTENSION} ; \
                        cd {AS2_ROS1_BRIDGE_PATH} &&  \
                        colcon build --symlink-install --packages-select ros1_bridge --cmake-force-configure')
    else:
        print('No ROS1 TO ROS2 BRIDGE found')


def clean_ros2_ws(args_list):
    # ask for confirmation before cleaning ros2 workspace
    if (not args_list.yes):
        print("Are you sure you want to clean the ROS2 workspace? (y/n)")
        answer = input()
        if(answer.lower() != "y"):
            return
    send_shell_command(f'cd {AS2_WS_PATH} && rm -rf build/ install/ log/')


def clean_ros1_ws(args_list):
    if not IS_ROS1_WS:
        print('No Aerostack2 ROS1 WS found')
        return
    if (not args_list.yes):
        # ask for confirmation before cleaning ros1 workspace
        print("Are you sure you want to clean the ROS1 workspace? (y/n)")
        answer = input()
        if(answer.lower() != "y"):
            return
    send_shell_command(f'cd {AS2_ROS1_WS_PATH} && rm -rf build/ devel/')
    send_shell_command(
        f'cd {AS2_ROS1_BRIDGE_PATH} && rm -rf build/ install/ log/')


def build_as2(args_list):
    # if args_list.:
    if(not args_list.ros1_only):
        compile_ros2_ws()

    # install ros1 dependencies
    if(not args_list.ros2_only):
        compile_ros1_ws()


def clean_as2(args_list):
    # if args_list.:
    # clean ros2 workspace
    if(not args_list.ros1_only):
        clean_ros2_ws(args_list)

    # clean ros1 workspace
    if(not args_list.ros2_only):
        clean_ros1_ws(args_list)


# main
if __name__ == "__main__":

    # argparser with a default string corresponding with the action to do
    parser = argparse.ArgumentParser(
        description=' Aerostack2 toolbox for ease the use of the AS2 pipeline')
    parser.add_argument('action', metavar='action', type=str, nargs='?', default='',
                        help='action to do (build, clean, run)')
    parser.add_argument(
        '--ros2-only', help='build only the ros2 packages', action='store_true')
    parser.add_argument(
        '--ros1-only', help='build only the ros1 packages', action='store_true')
    parser.add_argument(
        '-y', '--yes', help='answer yes to all questions', action='store_true')
    args = parser.parse_args()

    if args.action == "build":
        # print('building')
        build_as2(args)
    elif args.action == "clean":
        clean_as2(args)
    elif args.action == "run":
        # os.system("./as2")
        print('running')
    else:
        parser.print_help()
